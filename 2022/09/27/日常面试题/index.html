<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>日积月累 | 三乘以十的八次幂</title><meta name="keywords" content="必备"><meta name="author" content="三乘以十的八次幂"><meta name="copyright" content="三乘以十的八次幂"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vue 响应式原理一、简介Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节。 Vue 的数据双向绑定，响应式原理，其实就是通过 Object.definePropert">
<meta property="og:type" content="article">
<meta property="og:title" content="日积月累">
<meta property="og:url" content="https://jiaobingyang.gitee.io/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="三乘以十的八次幂">
<meta property="og:description" content="vue 响应式原理一、简介Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节。 Vue 的数据双向绑定，响应式原理，其实就是通过 Object.definePropert">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiaobingyang.gitee.io/img/13280497753579408.jpg">
<meta property="article:published_time" content="2022-09-27T12:26:26.000Z">
<meta property="article:modified_time" content="2022-09-27T23:45:49.999Z">
<meta property="article:author" content="三乘以十的八次幂">
<meta property="article:tag" content="必备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiaobingyang.gitee.io/img/13280497753579408.jpg"><link rel="shortcut icon" href="/img/13279652804370799.jpg"><link rel="canonical" href="https://jiaobingyang.gitee.io/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '日积月累',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 07:45:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13279652804370799.jpg" onerror="onerror=null;src='/img/wallhaven-e76roo.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/_data/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于本站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/13280497753579408.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">三乘以十的八次幂</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/_data/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于本站</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">日积月累</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-27T12:26:26.000Z" title="发表于 2022-09-27 20:26:26">2022-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-27T23:45:49.999Z" title="更新于 2022-09-28 07:45:49">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="日积月累"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="vue-响应式原理"><a href="#vue-响应式原理" class="headerlink" title="vue 响应式原理"></a>vue 响应式原理</h2><p>一、简介<br>Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节。</p>
<p>Vue 的数据双向绑定，响应式原理，其实就是通过 Object.defineProperty()结合发布者订阅者模式来实现的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; message:&#x27;hhhh&#x27;, name: &#x27;why&#x27;, &#125; Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">let value = obj[key]; Object.defineProperty(obj, key, &#123; set(newValue)&#123;</span><br><span class="line">console.log(&#x27;监听&#x27; + key + &#x27;改变 &#x27;) value = newValue; &#125;, get()&#123;</span><br><span class="line">console.log(&#x27;获取&#x27; + key + &#x27;对应的值&#x27;) return value &#125; &#125;) &#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="img"></p>
<p>Object.defineProperty()监听对象属性的改变<br>发布者订阅者模式通知需要改变的地方</p>
<p>Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher 自动触发重新 render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  //发布者 class Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs</span><br><span class="line">  = []; &#125; /* 在subs中添加一个Watcher对象 */ addSub(sub) &#123; this.subs.push(sub); &#125;</span><br><span class="line">/* 通知所有Watcher对象更新视图 */ notify() &#123;</span><br><span class="line">  this.subs.forEach((sub) =&gt; &#123;</span><br><span class="line">    sub.update();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; &#125; //订阅者 class Watcher &#123; constructor(name) &#123; this.name =</span><br><span class="line">name &#125; update() &#123; // 获得新值 console.log(this.name + &#x27;发生update&#x27;); &#125; &#125; const</span><br><span class="line">  dep = new Dep(); const w1 = new Watcher(&#x27;张三&#x27;); dep.addSub(w1) const w2 = new</span><br><span class="line">    Watcher(&#x27;李四); dep.addSub(w2) const w3 = new Watcher(&#x27;王五&#x27;); dep.addSub(w3)</span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/6.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt="img"></p>
<p>在 Observer 阶段，会为每个 key 都创建一个 dep 实例。并且，如果该 key 被某个 watcher 实例 get, 把该 watcher 实例加入 dep 实例的队列里。如果该 key 被 set, 则通知该 key 对应的 dep 实例， 然后 dep 实例会将依次通知队列里的 watcher 实例, 让它们去执行自身的回调方法</p>
<p>dep 实例是收集该 key 所有 watcher 实例的地方.</p>
<p>watcher 实例用来监听某个 key ，如果该 key 产生变化，便会执行 watcher 实例自身的回调</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="img"></p>
<h2 id="vue-的核心是什么"><a href="#vue-的核心是什么" class="headerlink" title="vue 的核心是什么"></a>vue 的核心是什么</h2><h3 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVVM`表示的是 `Model-View-ViewModel</span><br></pre></td></tr></table></figure>

<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据模型转化为 UI 展示出来，可以简单的理解为 HTML 页面</li>
<li>ViewModel：视图模型层，用来连接 Model 和 View，是 Model 和 View 之间的通信桥梁</li>
</ul>
<p>这时候需要一张直观的关系图，如下 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/4402c560-3ac6-11eb-85f6-6fac77c0c9b3.png" alt="image.png"></p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="#组件化"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/vue.html#%E7%BB%84%E4%BB%B6%E5%8C%96">#</a>组件化</h3><p>1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件 2.组件化的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="#指令系统"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/vue.html#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">#</a>指令系统</h3><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<ul>
<li>常用的指令<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
</ul>
</li>
</ul>
<p>没有指令之前我们是怎么做的？是不是先要获取到 DOM 然后在….干点啥</p>
<h2 id="什么是虚拟-dom、为什么虚拟-dom-能提升性能"><a href="#什么是虚拟-dom、为什么虚拟-dom-能提升性能" class="headerlink" title="什么是虚拟 dom、为什么虚拟 dom 能提升性能"></a>什么是虚拟 dom、为什么虚拟 dom 能提升性能</h2><h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3><p>虚拟 DOM （<code>Virtual DOM</code> ）这个概念相信大家都不陌生，从 <code>React</code> 到 <code>Vue</code> ，虚拟 <code>DOM</code> 为这两个框架都带来了跨平台的能力（<code>React-Native</code> 和 <code>Weex</code>）</p>
<p>实际上它只是一层对真实<code>DOM</code>的抽象，以<code>JavaScript</code> 对象 (<code>VNode</code> 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上</p>
<p>在<code>Javascript</code>对象中，虚拟<code>DOM</code> 表现为一个 <code>Object</code>对象。并且最少包含标签名 (<code>tag</code>)、属性 (<code>attrs</code>) 和子元素对象 (<code>children</code>) 三个属性，不同框架对这三个属性的名命可能会有差别</p>
<p>创建虚拟<code>DOM</code>就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟<code>DOM</code>对象的节点与真实<code>DOM</code>的属性一一照应</p>
<p>在<code>vue</code>中同样使用到了虚拟<code>DOM</code>技术</p>
<p>定义真实<code>DOM</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p&quot;</span>&gt;</span>节点内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>vue</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>观察<code>render</code>的<code>render</code>，我们能得到虚拟<code>DOM</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="variable language_">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;, [</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&quot;p&quot;</span>, &#123; <span class="attr">staticClass</span>: <span class="string">&quot;p&quot;</span> &#125;, [<span class="title function_">_v</span>(<span class="string">&quot;节点内容&quot;</span>)]),</span><br><span class="line">      <span class="title function_">_v</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&quot;h3&quot;</span>, [<span class="title function_">_v</span>(<span class="title function_">_s</span>(foo))]),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过<code>VNode</code>，<code>vue</code>可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过<code>diff</code>算法得出一些需要修改的最小单位,再更新视图，减少了<code>dom</code>操作，提高了性能</p>
<h3 id="为什么需要虚拟-DOM"><a href="#为什么需要虚拟-DOM" class="headerlink" title="为什么需要虚拟 DOM"></a>为什么需要虚拟 DOM</h3><p><code>DOM</code>是很慢的，其元素非常庞大，页面的性能问题，大部分都是由<code>DOM</code>操作引起的</p>
<p>真实的<code>DOM</code>节点，哪怕一个最简单的<code>div</code>也包含着很多属性，可以打印出来直观感受一下： <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/cc95c7f0-442c-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>由此可见，操作<code>DOM</code>的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p>
<p><strong>举个例子：</strong></p>
<p>你用传统的原生<code>api</code>或<code>jQuery</code>去操作<code>DOM</code>时，浏览器会从构建<code>DOM</code>树开始从头到尾执行一遍流程</p>
<p>当你在一次操作时，需要更新 10 个<code>DOM</code>节点，浏览器没这么智能，收到第一个更新<code>DOM</code>请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程</p>
<p>而通过<code>VNode</code>，同样更新 10 个<code>DOM</code>节点，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这 10 次更新的<code>diff</code>内容保存到本地的一个<code>js</code>对象中，最终将这个<code>js</code>对象一次性<code>attach</code>到<code>DOM</code>树上，避免大量的无谓计算</p>
<blockquote>
<p>很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI</p>
</blockquote>
<h3 id="如何实现虚拟-DOM"><a href="#如何实现虚拟-DOM" class="headerlink" title="如何实现虚拟 DOM"></a>如何实现虚拟 DOM</h3><p>首先可以看看<code>vue</code>中<code>VNode</code>的结构</p>
<p>源码位置：src&#x2F;core&#x2F;vdom&#x2F;vnode.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">functionalContext</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// only for functional component root nodes</span></span><br><span class="line">  <span class="attr">key</span>: string | number | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line">  <span class="attr">raw</span>: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tag?: string,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: string,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">    <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children;</span><br><span class="line">    <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text;</span><br><span class="line">    <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm;</span><br><span class="line">    <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*编译作用域*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context;</span><br><span class="line">    <span class="comment">/*函数化组件作用域*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">functionalContext</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span>;</span><br><span class="line">    <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions;</span><br><span class="line">    <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next https://github.com/answershuto/learnVue*/</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">child</span>(): <span class="title class_">Component</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对<code>VNode</code>进行稍微的说明：</p>
<ul>
<li>所有对象的 <code>context</code> 选项都指向了 <code>Vue</code> 实例</li>
<li><code>elm</code> 属性则指向了其相对应的真实 <code>DOM</code> 节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue`是通过`createElement`生成`VNode</span><br></pre></td></tr></table></figure>

<p>源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-element.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: Component,</span></span><br><span class="line"><span class="params">  tag: any,</span></span><br><span class="line"><span class="params">  data: any,</span></span><br><span class="line"><span class="params">  children: any,</span></span><br><span class="line"><span class="params">  normalizationType: any,</span></span><br><span class="line"><span class="params">  alwaysNormalize: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children;</span><br><span class="line">    children = data;</span><br><span class="line">    data = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以看到<code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，对参数的传入进行了判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">    context: Component,</span></span><br><span class="line"><span class="params">    tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: any,</span></span><br><span class="line"><span class="params">    normalizationType?: number</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((<span class="attr">data</span>: any).<span class="property">__ob__</span>)) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">            <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">            context<span class="string">`</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        return createEmptyVNode()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // object syntax in v-bind</span></span><br><span class="line"><span class="string">    if (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span></span><br><span class="line"><span class="string">        tag = data.is</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (!tag) &#123;</span></span><br><span class="line"><span class="string">        // in case of component :is set to falsy value</span></span><br><span class="line"><span class="string">        return createEmptyVNode()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    // support single function children as default scoped slot</span></span><br><span class="line"><span class="string">    if (Array.isArray(children) &amp;&amp;</span></span><br><span class="line"><span class="string">        typeof children[0] === &#x27;function&#x27;</span></span><br><span class="line"><span class="string">    ) &#123;</span></span><br><span class="line"><span class="string">        data = data || &#123;&#125;</span></span><br><span class="line"><span class="string">        data.scopedSlots = &#123; default: children[0] &#125;</span></span><br><span class="line"><span class="string">        children.length = 0</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (normalizationType === ALWAYS_NORMALIZE) &#123;</span></span><br><span class="line"><span class="string">        children = normalizeChildren(children)</span></span><br><span class="line"><span class="string">    &#125; else if ( === SIMPLE_NORMALIZE) &#123;</span></span><br><span class="line"><span class="string">        children = simpleNormalizeChildren(children)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">	// 创建VNode</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>_createElement</code>接收 5 个参数：</p>
<ul>
<li><code>context</code> 表示 <code>VNode</code> 的上下文环境，是 <code>Component</code> 类型</li>
<li>tag 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code></li>
<li><code>data</code> 表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code> 类型</li>
<li><code>children</code> 表示当前 <code>VNode</code>的子节点，它是任意类型的</li>
<li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 <code>render</code> 函数是编译生成的还是用户手写的</li>
</ul>
<p>根据<code>normalizationType</code> 的类型，<code>children</code>会有不同的定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>simpleNormalizeChildren</code>方法调用场景是 <code>render</code> 函数是编译生成的</p>
<p><code>normalizeChildren</code>方法调用场景分为下面两种：</p>
<ul>
<li><code>render</code> 函数是用户手写的</li>
<li>编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组</li>
</ul>
<p>无论是<code>simpleNormalizeChildren</code>还是<code>normalizeChildren</code>都是对<code>children</code>进行规范（使<code>children</code> 变成了一个类型为 <code>VNode</code> 的 <code>Array</code>），这里就不展开说了</p>
<p>规范化<code>children</code>的源码位置在：src&#x2F;core&#x2F;vdom&#x2F;helpers&#x2F;normalzie-children.js</p>
<p>在规范化<code>children</code>后，就去创建<code>VNode</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode, ns;</span><br><span class="line"><span class="comment">// 对tag进行判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Ctor</span>;</span><br><span class="line">  ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag);</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">    <span class="comment">// 如果是内置的节点，则直接创建一个普通VNode</span></span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      config.<span class="title function_">parsePlatformTagName</span>(tag),</span><br><span class="line">      data,</span><br><span class="line">      children,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      context</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="title function_">isDef</span>((<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&quot;components&quot;</span>, tag)))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    <span class="comment">// 如果是component类型，则会通过createComponent创建VNode节点</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(tag, data, children, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = <span class="title function_">createComponent</span>(tag, data, context, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createComponent`同样是创建`VNode</span><br></pre></td></tr></table></figure>

<p>源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-component.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  data: ?VNodeData,</span></span><br><span class="line"><span class="params">  context: Component,</span></span><br><span class="line"><span class="params">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">  tag?: string</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建子类构造函数</span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if at this stage it&#x27;s not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Ctor</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) &#123;</span><br><span class="line">    asyncFactory = <span class="title class_">Ctor</span>;</span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor, context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(asyncFactory, data, context, children, tag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">  <span class="comment">// component constructor creation</span></span><br><span class="line">  <span class="title function_">resolveConstructorOptions</span>(<span class="title class_">Ctor</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data.<span class="property">model</span>)) &#123;</span><br><span class="line">    <span class="title function_">transformModel</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = <span class="title function_">extractPropsFromVNodeData</span>(data, <span class="title class_">Ctor</span>, tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">functional</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createFunctionalComponent</span>(<span class="title class_">Ctor</span>, propsData, data, context, children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.<span class="property">on</span>;</span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.<span class="property">on</span> = data.<span class="property">nativeOn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">abstract</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = data.<span class="property">slot</span>;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.<span class="property">slot</span> = slot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装组件钩子函数，把钩子函数合并到data.hook中</span></span><br><span class="line">  <span class="title function_">installComponentHooks</span>(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化一个VNode返回。组件的VNode是没有children的</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag;</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>,</span><br><span class="line">    data,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; <span class="title function_">isRecyclableComponent</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">renderRecyclableComponentTemplate</span>(vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微提下<code>createComponent</code>生成<code>VNode</code>的三个关键流程：</p>
<ul>
<li>构造子类构造函数<code>Ctor</code></li>
<li><code>installComponentHooks</code>安装组件钩子函数</li>
<li>实例化 <code>vnode</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96">https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6876711874050818061">https://juejin.cn/post/6876711874050818061</a></li>
</ul>
<h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><h3 id="组件化-1"><a href="#组件化-1" class="headerlink" title="#组件化"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/vue.html#%E7%BB%84%E4%BB%B6%E5%8C%96">#</a>组件化</h3><p>1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件 2.组件化的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h2 id="组件通信的方式有哪些"><a href="#组件通信的方式有哪些" class="headerlink" title="组件通信的方式有哪些"></a>组件通信的方式有哪些</h2><blockquote>
<p>组件通信一般分为以下几种情况：</p>
</blockquote>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨多层级组件通信</li>
</ul>
<blockquote>
<p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p>
</blockquote>
<p><strong>1. 父子通信</strong></p>
<ul>
<li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li>
<li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>，而是必须通过发送事件的方式告知父组件修改数据。</li>
<li>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 <code>UI</code> 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</li>
<li>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</li>
<li>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</li>
<li><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</li>
<li><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.sync</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上写法等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;v =&gt; value = v&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, <span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        @程序员poetry: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 兄弟组件通信</strong></p>
<blockquote>
<p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
</blockquote>
<p><strong>3. 跨多层次组件通信</strong></p>
<blockquote>
<p>对于这种情况可以使用 <code>Vue 2.2</code> 新增的 <code>API provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p>
</blockquote>
<p>假设有父组件 <code>A</code>，然后有一个跨多层级的子组件 <code>B</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>终极办法解决一切通信问题</strong></p>
<p>只要你不怕麻烦，可以使用 <code>Vuex</code> 或者 <code>Event Bus</code> 解决上述所有的通信情况。</p>
<h2 id="说一下对-spa-的理解"><a href="#说一下对-spa-的理解" class="headerlink" title="说一下对 spa 的理解"></a>说一下对 spa 的理解</h2><h3 id="你对-SPA-单页面的理解，它的优缺点分别是什么？如何实现-SPA-应用呢"><a href="#你对-SPA-单页面的理解，它的优缺点分别是什么？如何实现-SPA-应用呢" class="headerlink" title="你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢"></a>你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/cf6aa320-3ac6-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h3 id="一、什么是-SPA"><a href="#一、什么是-SPA" class="headerlink" title="#一、什么是 SPA"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa">#</a>一、什么是 SPA</h3><p>SPA（single-page application），翻译过来就是单页应用<code>SPA</code>是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/df14a5a0-3ac6-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>我们熟知的 JS 框架如<code>react</code>,<code>vue</code>,<code>angular</code>,<code>ember</code>都属于<code>SPA</code></p>
<h3 id="二、SPA-和-MPA-的区别"><a href="#二、SPA-和-MPA-的区别" class="headerlink" title="#二、SPA 和 MPA 的区别"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E4%BA%8C%E3%80%81spa%E5%92%8Cmpa%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>二、SPA 和 MPA 的区别</h3><p>上面大家已经对单页面有所了解了，下面来讲讲多页应用 MPA（MultiPage-page application），翻译过来就是多页应用在<code>MPA</code>中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载<code>html</code>、<code>css</code>、<code>js</code>文件，公共文件则根据需求按需加载如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/eeb13aa0-3ac6-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h4 id="单页应用与多页应用的区别"><a href="#单页应用与多页应用的区别" class="headerlink" title="#单页应用与多页应用的区别"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>单页应用与多页应用的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">单页面应用（SPA）</th>
<th align="left">多页面应用（MPA）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">组成</td>
<td align="left">一个主页面和多个页面片段</td>
<td align="left">多个主页面</td>
</tr>
<tr>
<td align="left">刷新方式</td>
<td align="left">局部刷新</td>
<td align="left">整页刷新</td>
</tr>
<tr>
<td align="left">url 模式</td>
<td align="left">哈希模式</td>
<td align="left">历史模式</td>
</tr>
<tr>
<td align="left">SEO 搜索引擎优化</td>
<td align="left">难实现，可使用 SSR 方式改善</td>
<td align="left">容易实现</td>
</tr>
<tr>
<td align="left">数据传递</td>
<td align="left">容易</td>
<td align="left">通过 url、cookie、localStorage 等传递</td>
</tr>
<tr>
<td align="left">页面切换</td>
<td align="left">速度快，用户体验良好</td>
<td align="left">切换加载资源，速度慢，用户体验差</td>
</tr>
<tr>
<td align="left">维护成本</td>
<td align="left">相对容易</td>
<td align="left">相对复杂</td>
</tr>
</tbody></table>
<h4 id="单页应用优缺点"><a href="#单页应用优缺点" class="headerlink" title="#单页应用优缺点"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9">#</a>单页应用优缺点</h4><p>优点：</p>
<ul>
<li>具有桌面应用的即时性、网站的可移植性和可访问性</li>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>良好的前后端分离，分工更明确</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次渲染速度相对较慢</li>
<li></li>
</ul>
<h3 id="三、实现一个-SPA"><a href="#三、实现一个-SPA" class="headerlink" title="#三、实现一个 SPA"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAspa">#</a>三、实现一个 SPA</h3><h4 id="原理"><a href="#原理" class="headerlink" title="#原理"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%8E%9F%E7%90%86">#</a>原理</h4><ol>
<li>监听地址栏中<code>hash</code>变化驱动界面变化</li>
<li>用<code>pushsate</code>记录浏览器的历史，驱动界面发送变化</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/fc95bf60-3ac6-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="#实现"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%AE%9E%E7%8E%B0">#</a>实现</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="#hash 模式"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#hash-%E6%A8%A1%E5%BC%8F">#</a><code>hash</code> 模式</h5><p>核心通过监听<code>url</code>中的<code>hash</code>来进行路由跳转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Router</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;; <span class="comment">// 存放路由path及callback</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentUrl</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听路由change调用相对应的路由回调</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="variable language_">this</span>.<span class="property">refresh</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="variable language_">this</span>.<span class="property">refresh</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 router</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&quot;/&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;page1&quot;</span>));</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&quot;/page2&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;page2&quot;</span>));</span><br><span class="line"></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">// page1</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&quot;/page2&quot;</span>); <span class="comment">// page2</span></span><br></pre></td></tr></table></figure>

<h5 id="history-模式"><a href="#history-模式" class="headerlink" title="#history 模式"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#history%E6%A8%A1%E5%BC%8F">#</a>history 模式</h5><p><code>history</code> 模式核心借用 <code>HTML5 history api</code>，<code>api</code> 提供了丰富的 <code>router</code> 相关属性先了解一个几个相关的 api</p>
<ul>
<li><code>history.pushState</code> 浏览器历史纪录添加记录</li>
<li><code>history.replaceState</code>修改浏览器历史纪录中当前纪录</li>
<li><code>history.popState</code> 当 <code>history</code> 发生变化时触发</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Router</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">listerPopState</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">replaceState</span>(&#123; <span class="attr">path</span>: path &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">pushState</span>(&#123; <span class="attr">path</span>: path &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">listerPopState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> path = e.<span class="property">state</span> &amp;&amp; e.<span class="property">state</span>.<span class="property">path</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routers</span>[path]();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Router</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&quot;/&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;page1&quot;</span>));</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&quot;/page2&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;page2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&quot;/page2&quot;</span>); <span class="comment">// page2</span></span><br></pre></td></tr></table></figure>

<h3 id="四、题外话：如何给-SPA-做-SEO"><a href="#四、题外话：如何给-SPA-做-SEO" class="headerlink" title="#四、题外话：如何给 SPA 做 SEO"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%9B%9B%E3%80%81%E9%A2%98%E5%A4%96%E8%AF%9D-%E5%A6%82%E4%BD%95%E7%BB%99spa%E5%81%9Aseo">#</a>四、题外话：如何给 SPA 做 SEO</h3><p>下面给出基于<code>Vue</code>的<code>SPA</code>如何实现<code>SEO</code>的三种方式</p>
<ol>
<li><strong>SSR 服务端渲染</strong></li>
</ol>
<p>将组件或页面通过服务器生成 html，再返回给浏览器，如<code>nuxt.js</code></p>
<ol>
<li><strong>静态化</strong></li>
</ol>
<p>目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过 WEB 服务器的 <code>URL Rewrite</code>的方式，它的原理是通过 web 服务器内部模块按一定规则将外部的 URL 请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现 URL 静态化的效果</p>
<ol>
<li><strong>使用<code>Phantomjs</code>针对爬虫处理</strong></li>
</ol>
<p>原理是通过<code>Nginx</code>配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个<code>node server</code>，再通过<code>PhantomJS</code>来解析完整的<code>HTML</code>，返回给爬虫。下面是大致流程图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/25be6630-3ac7-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h3 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="#参考文献"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/spa.html#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">#</a>参考文献</h3><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019623624">https://segmentfault.com/a/1190000019623624</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903512107663368">https://juejin.cn/post/6844903512107663368</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/constantince/p/5586851.html">https://www.cnblogs.com/constantince/p/5586851.html</a></li>
</ul>
<h2 id="vue-中给对象添加属性为什么界面不会刷新"><a href="#vue-中给对象添加属性为什么界面不会刷新" class="headerlink" title="vue 中给对象添加属性为什么界面不会刷新"></a>vue 中给对象添加属性为什么界面不会刷新</h2><p>问题<br>当我们给 data 里面声明的对象添加一个新属性，这个新属性是不会动态更新视图的。</p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; obj &#125;&#125;&lt;br /&gt;</span><br><span class="line">    &lt;button @click=&quot;addProperty&quot;&gt;动态添加新属性&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: &#123;</span><br><span class="line">        oldProperty: &quot;旧值&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addProperty() &#123;</span><br><span class="line">      this.obj.newProperty = &quot;新值&quot;;</span><br><span class="line">      console.log(this.obj);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在浏览器中输出的是最新结果，但是页面视图并没有更新</p>
<p>原因<br>vue2 使用 Object.defineProperty 实现数据响应式</p>
<p>组件初始化时，对 data 中的 obj 进行递归遍历，对 obj 的每一个属性进行劫持，添加 set,get 方法。我们后来新加 的 newProperty 属性，并没有通过 Object.defineProperty 设置成响应式数据，所以修改后不会视图更新</p>
<p>解决<br>Vue 不允许在已经创建的实例上动态添加新的响应式属性</p>
<p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p>
<p>如果为对象添加少量的新属性，可以直接采用 Vue.set()<br>​ 如果需要为新对象添加大量的新属性，则通过 Object.assign()创建新对象<br>​ 如果你需要进行强制刷新时，可采取$forceUpdate() (不建议)<br>注意:vue3 是用过 proxy 实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p>
<h2 id="vue-中的-key-属性的作用"><a href="#vue-中的-key-属性的作用" class="headerlink" title="vue 中的 key 属性的作用"></a>vue 中的 key 属性的作用</h2><p>先来给官方的回答，再讲讲我自己的理解，哈哈。</p>
<ol>
<li><p>key 的作用主要是为了高效的更新虚拟 DOM，其原理是 vue 在 patch 过程中 会执行 patch vnode，patch vnode 的过程中会执行 updateChildren 这个方法【patch.js 中 重排算法】。 他会去更新两个新旧的子元素。在这个过程中。通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个 patch 过程更加高效，减少 DOM 操作量，提高性能。</p>
</li>
<li><p>另外，若不设置 key 还可能在列表更新时引发一些隐蔽的 bug【比如说有一行不应该更新的，但是更新了。】</p>
</li>
<li><p>vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。</p>
</li>
</ol>
<p>比如说在 data 里面，你有一个数组数据：user:[A , B , C , D , E]，你先在索引值为 2 也就是 C 那里插入一个 F，如果你没有给每一项设置 key 的话，Vue 会更新 A、B 后的所有项，（这里就有点涉及到源码，因为没有设置 key,所以他们的 key 都是 undefined,然后 A、B 也没有改变啥，所以就不会更新 A、B，）然后再插入 E，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/7.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/8.png" alt="img"></p>
<p>就是他会遍历(A、B)后每一项，然后更新(A、B)后每一项的内容，做了大量的 dom 操作。</p>
<p>如果使用 key 呢，那就直接如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/9.png" alt="img"></p>
<p>Vue 就可以直接通过可以 key 找到对应的 dom 节点，然后插入 F，把后面的数据往后排，不会说更新(A、B)后每一项的内容，就减少的大量的 dom 操作。<br>————————————————<br>版权声明：本文为 CSDN 博主「武陵人捕鱼为业~~~」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44914088/article/details/122119054">https://blog.csdn.net/weixin_44914088/article/details/122119054</a></p>
<h2 id="vue-的修饰符有哪些"><a href="#vue-的修饰符有哪些" class="headerlink" title="vue 的修饰符有哪些"></a>vue 的修饰符有哪些</h2><h3 id="vue-中修饰符分为以下五种"><a href="#vue-中修饰符分为以下五种" class="headerlink" title="vue 中修饰符分为以下五种"></a>vue 中修饰符分为以下五种</h3><ul>
<li>表单修饰符</li>
<li>事件修饰符</li>
<li>鼠标按键修饰符</li>
<li>键值修饰符</li>
<li><code>v-bind</code>修饰符</li>
</ul>
<p><strong>1. 表单修饰符</strong></p>
<p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p>
<p>关于表单的修饰符有如下：</p>
<ul>
<li><code>lazy</code></li>
</ul>
<p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>trim</code></li>
</ul>
<p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>number</code></li>
</ul>
<p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<p><strong>2. 事件修饰符</strong></p>
<p>事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符</p>
<ul>
<li><code>.stop</code> 阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;shout(2)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//只输出1 @程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.prevent</code> 阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.capture</code> 使用事件捕获模式，使事件触发从包含这个元素的顶层开始往下触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span></span><br><span class="line">  obj1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;shout(2)&quot;</span>&gt;</span></span><br><span class="line">    obj2</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;shout(3)&quot;</span>&gt;</span></span><br><span class="line">      obj3</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;shout(4)&quot;</span>&gt;</span>obj4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 输出结构: 1 2 4 3 @程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.self</code> 只当在 <code>event.target</code> 是当前元素自身时触发处理函数</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p>
</blockquote>
<ul>
<li><code>.once</code> 绑定了事件以后只能触发一次，第二次就不会触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.passive</code> 告诉浏览器你不想阻止事件的默认行为</li>
</ul>
<p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</li>
<li><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</li>
</ul>
</blockquote>
<ul>
<li><code>native</code> 让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用.native修饰符来操作普通HTML标签是会令事件失效的 --&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<p><strong>3. 鼠标按钮修饰符</strong></p>
<p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p>
<ul>
<li><code>.left</code> 左键点击</li>
<li><code>.right</code> 右键点击</li>
<li><code>.middle</code> 中键点击</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.left</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.right</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.middle</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<p><strong>4. 键盘事件的修饰符</strong></p>
<p>键盘修饰符是用来修饰键盘事件（<code>onkeyup</code>，<code>onkeydown</code>）的，有如下：</p>
<p><code>keyCode</code>存在很多，但 vue 为我们提供了别名，分为以下两种：</p>
<ul>
<li><strong>普通键</strong>（<code>enter</code>、<code>tab</code>、<code>delete</code>、<code>space</code>、<code>esc</code>、<code>up</code>、<code>down</code>、<code>left</code>、<code>right</code>…）</li>
<li><strong>系统修饰键</strong>（<code>ctrl</code>、<code>alt</code>、<code>meta</code>、<code>shift</code>…）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有按键为keyCode的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.keyCode</span>=<span class="string">&quot;shout()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<p>还可以通过以下方式自定义一些全局的键盘码别名</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = 113</span><br><span class="line"></span><br><span class="line">        @程序员poetry: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. v-bind 修饰符</strong></p>
<p><code>v-bind</code>修饰符主要是为属性进行操作，用来分别有如下：</p>
<ul>
<li><strong>async</strong> 能对<code>props</code>进行一个双向绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;comp :myMessage.<span class="property">sync</span>=<span class="string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:myMessage&#x27;</span>,params);</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上这种方法相当于以下的简写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父亲组件</span></span><br><span class="line">&lt;comp :myMessage=<span class="string">&quot;bar&quot;</span> @<span class="attr">update</span>:myMessage=<span class="string">&quot;func&quot;</span>&gt;&lt;/comp&gt;</span><br><span class="line"><span class="title function_">func</span>(<span class="params">e</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件js</span></span><br><span class="line"><span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:myMessage&#x27;</span>,params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>async</code>需要注意以下两点：</p>
<ul>
<li>使用<code>sync</code>的时候，子组件传递的事件名格式必须为<code>update:value</code>，其中<code>value</code>必须与子组件中<code>props</code>中声明的名称完全一致</li>
<li>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用</li>
<li><strong>prop</strong> 设置自定义标签属性，避免暴露数据，防止污染 HTML 结构</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">title</span>=<span class="string">&quot;title1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">:index.prop</span>=<span class="string">&quot;index&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>camel</strong> 将命名变为驼峰命名法，如将<code>view-Box</code>属性名转换为 <code>viewBox</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">:viewBox</span>=<span class="string">&quot;viewBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@程序员poetry: 代码已经复制到剪贴板</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="#应用场景"></a><a target="_blank" rel="noopener" href="https://interview2.poetries.top/docs/excellent-docs/7-Vue.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>应用场景</h3><p>根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：</p>
<ul>
<li><code>.stop</code>：阻止事件冒泡</li>
<li><code>.native</code>：绑定原生事件</li>
<li><code>.once</code>：事件只执行一次</li>
<li><code>.self</code> ：将事件绑定在自身身上，相当于阻止事件冒泡</li>
<li><code>.prevent</code>：阻止默认事件</li>
<li><code>.caption</code>：用于事件捕获</li>
<li><code>.once</code>：只触发一次</li>
<li><code>.keyCode</code>：监听特定键盘按下</li>
<li><code>.right</code>：右键</li>
</ul>
<h2 id="vue-的-diff-算法是做什么的-对比方式"><a href="#vue-的-diff-算法是做什么的-对比方式" class="headerlink" title="vue 的 diff 算法是做什么的 对比方式"></a>vue 的 diff 算法是做什么的 对比方式</h2><h3 id="4-1-React-Diff"><a href="#4-1-React-Diff" class="headerlink" title="4.1 React-Diff"></a>4.1 React-Diff</h3><p>React 的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。</p>
<p><strong>1. 实现原理</strong></p>
<p>来看这样一个例子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211358420.png" alt="img"></p>
<p><code>nextList</code>为新的列表，<code>prevList</code>为旧列表。这个例子我们一眼能看出来，新列表是不需要进行移动的。下面我用<code>react</code>的递增思想，解释一下为什么新列表中的节点不需要移动。</p>
<p>我们首先遍历<code>nextList</code>，并且找到每一个节点，在<code>prevList</code>中的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">prevList, nextList</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextItem = nextList[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevList.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevItem = prevList[j]</span><br><span class="line">            <span class="keyword">if</span> (nextItem === prevItem) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到位置以后，与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个<code>lastIndex</code>来记录上一个节点的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">prevList, nextList</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextItem = nextList[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevList.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevItem = prevList[j]</span><br><span class="line">            <span class="keyword">if</span> (nextItem === prevItem) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 需要移动节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>nextList</code>每个节点在<code>prevList</code>的位置为<code>0 1 2 3</code>。每一项都要比前一项要大，所以不需要移动，这就是<code>react</code>的<code>diff</code>算法的原理。</p>
<p><strong>2. 找到需要移动的节点</strong></p>
<p>在上一小节中，我们是通过对比值是否相等，查找的对应位置。但是在 vdom 中，每一个节点都是一个 vNode，我们应该如何进行判断呢？</p>
<p>答案就是<code>key</code>，我们通过对每个节点的<code>key</code>进行赋值，并且让处于同一<code>children</code>数组下的<code>vnode</code>的<code>key</code>都不相同，以此来确定每个节点的唯一性，并进行新旧列表的对比。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactDiff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextChild = nextChildren[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChild = prevChildren[j]</span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> === prevChild.<span class="property">key</span>) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(prevChild, nextChild, parent)</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 需要移动节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 移动节点</strong></p>
<p>首先我们先明确一点，移动节点所指的节点是<code>DOM</code>节点。<code>vnode.el</code>指向该节点对应的真实<code>DOM</code>节点。<code>patch</code>方法会将更新过后的<code>DOM</code>节点，赋值给<strong>新的</strong><code>vnode</code>的<code>el</code>属性。</p>
<blockquote>
<p>为了画图方便，我们用<code>key</code>的值来表示<code>vnode</code>节点。为了行文方便，我们把<code>key</code>值为<code>a</code>的<code>vnode</code>简写为<code>vnode-a</code>，<code>vnode-a</code>对应的真实 DOM 节点为<code>DOM-A</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211358473.png" alt="img"></p>
<p>我们来将上图的例子代入<code>reactDiff</code>中执行。我们遍历<strong>新列表</strong>，并查找<code>vnode</code>在<strong>旧列表</strong>中的位置。当遍历到<code>vnode-d</code>时，之前遍历在<strong>旧列表</strong>的位置为<code>0 &lt; 2 &lt; 3</code>，说明<code>A C D</code>这三个节点都是不需要移动的。此时<code>lastIndex = 3</code>, 并进入下一次循环，发现<code>vnode-b</code>在<strong>旧列表</strong>的<code>index</code>为<code>1</code>，<code>1 &lt; 3</code>，说明<code>DOM-B</code>要移动。</p>
<p>通过观察我们能发现，只需要把<code>DOM-B</code>移动到<code>DOM-D</code>之后就可以了。也就是<strong>找到需要移动的 VNode，我们称该 VNode 为 α，将 α 对应的真实的 DOM 节点移动到，α 在<code>新列表</code>中的前一个 VNode 对应的真实 DOM 的后面。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211358728.png" alt="img"></p>
<p>在上述的例子中，就是将<code>vnode-b</code>对应的真实 DOM 节点<code>DOM-B</code>, 移动到<code>vnode-b</code>在新列表中的前一个<code>VNode</code>——<code>vnode-d</code>对应的真实 DOM 节点<code>DOM-D</code>的后面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactDiff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextChild = nextChildren[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChild = prevChildren[j]</span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> === prevChild.<span class="property">key</span>) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(prevChild, nextChild, parent)</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 移动到前一个节点的后面</span></span><br><span class="line">                    <span class="keyword">let</span> refNode = nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span>;</span><br><span class="line">                    parent.<span class="title function_">insertBefore</span>(nextChild.<span class="property">el</span>, refNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么是这样移动的呢？首先我们列表是<code>从头到尾</code>遍历的。这就意味着对于当前<code>VNode</code>节点来说，该节点之前的所有节点都是排好序的，如果该节点需要移动，那么只需要将 DOM 节点移动到前一个<code>vnode</code>节点之后就可以，因为在<strong>新列表</strong>中<code>vnode</code>的顺序就是这样的。</p>
<p><strong>4. 添加节点</strong></p>
<p>上一小节我们只讲了如何移动节点，但是忽略了另外一种情况，就是在<strong>新列表</strong>中有全新的<code>VNode</code>节点，在<strong>旧列表</strong>中找不到。遇到这种情况，我们需要根据新的<code>VNode</code>节点生成<code>DOM</code>节点，并插入<code>DOM</code>树中。</p>
<p>至此，我们面临两个问题：1.如何发现全新的节点、2. 生成的<code>DOM</code>节点插入到哪里</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211358228.png" alt="img"></p>
<p>我们先来解决第一个问题，找节点还是比较简单的，我们定义一个<code>find</code>变量值为<code>false</code>。如果在<strong>旧列表</strong>找到了<code>key</code> 相同的<code>vnode</code>，就将<code>find</code>的值改为<code>true</code>。当遍历结束后判断<code>find</code>值，如果为<code>false</code>，说明当前节点为新节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactDiff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextChild = nextChildren[i],</span><br><span class="line">            find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChild = prevChildren[j]</span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> === prevChild.<span class="property">key</span>) &#123;</span><br><span class="line">                find = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">patch</span>(prevChild, nextChild, parent)</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 移动到前一个节点的后面</span></span><br><span class="line">                    <span class="keyword">let</span> refNode = nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span>;</span><br><span class="line">                    parent.<span class="title function_">insertBefore</span>(nextChild.<span class="property">el</span>, refNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            <span class="comment">// 插入新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到新节点后，下一步就是插入到哪里了，这里的逻辑其实是和移动节点的逻辑是一样的。我们观察上图可以发现，新的<code>vnode-c</code>是紧跟在<code>vnode-b</code>后面的，并且<code>vnode-b</code>的 DOM 节点——<code>DOM-B</code>是已经排好序的，所以我们只需要将<code>vnode-c</code>生成的 DOM 节点插入到<code>DOM-B</code>之后就可以了。</p>
<p>但是这里有一种特殊情况需要注意，就是新的节点位于<strong>新列表</strong>的第一个，这时候我们需要找到<strong>旧列表</strong>第一个节点，将新节点插入到原来第一个节点之前就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactDiff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextChild = nextChildren[i],</span><br><span class="line">            find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChild = prevChildren[j]</span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> === prevChild.<span class="property">key</span>) &#123;</span><br><span class="line">                find = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">patch</span>(prevChild, nextChild, parent)</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 移动到前一个节点的后面</span></span><br><span class="line">                    <span class="keyword">let</span> refNode = nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span>;</span><br><span class="line">                    parent.<span class="title function_">insertBefore</span>(nextChild.<span class="property">el</span>, refNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            <span class="comment">// 插入新节点</span></span><br><span class="line">            <span class="keyword">let</span> refNode = i &lt;= <span class="number">0</span></span><br><span class="line">                            ? prevChildren[<span class="number">0</span>].<span class="property">el</span></span><br><span class="line">                            : nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span></span><br><span class="line">            <span class="title function_">mount</span>(nextChild, parent, refNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. 移除节点</strong></p>
<p>有增就有减，当旧的节点不在<strong>新列表</strong>中时，我们就将其对应的 DOM 节点移除。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211358441.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactDiff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextChild = nextChildren[i],</span><br><span class="line">            find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; prevChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChild = prevChildren[j]</span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> === prevChild.<span class="property">key</span>) &#123;</span><br><span class="line">                find = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">patch</span>(prevChild, nextChild, parent)</span><br><span class="line">                <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="comment">// 移动到前一个节点的后面</span></span><br><span class="line">                    <span class="keyword">let</span> refNode = nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span>;</span><br><span class="line">                    parent.<span class="title function_">insertBefore</span>(nextChild.<span class="property">el</span>, refNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span></span><br><span class="line">                    lastIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            <span class="comment">// 插入新节点</span></span><br><span class="line">            <span class="keyword">let</span> refNode = i &lt;= <span class="number">0</span></span><br><span class="line">                            ? prevChildren[<span class="number">0</span>].<span class="property">el</span></span><br><span class="line">                            : nextChildren[i - <span class="number">1</span>].<span class="property">el</span>.<span class="property">nextSibling</span></span><br><span class="line">            <span class="title function_">mount</span>(nextChild, parent, refNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevChild = prevChildren[i],</span><br><span class="line">            key = prevChild.<span class="property">key</span>,</span><br><span class="line">            has = nextChildren.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">key</span> === key);</span><br><span class="line">        <span class="keyword">if</span> (!has) parent.<span class="title function_">removeChild</span>(prevChild.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>6. 优化与不足</strong></p>
<p>以上就是 React 的 diff 算法的思路。</p>
<p>目前的<code>reactDiff</code>的时间复杂度为<code>O(m*n)</code>，我们可以用空间换时间，把<code>key</code>与<code>index</code>的关系维护成一个<code>Map</code>，从而将时间复杂度降低为<code>O(n)</code>，具体的代码可以<a target="_blank" rel="noopener" href="https://github.com/sunyanzhe/virtual-dom/blob/master/src/diff/react-diff.js">查看此项目 (opens new window)</a>。</p>
<p>我们接下来看这样一个例子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359786.png" alt="img"></p>
<p>根据<code>reactDiff</code>的思路，我们需要先将<code>DOM-A</code>移动到<code>DOM-C</code>之后，然后再将<code>DOM-B</code>移动到<code>DOM-A</code>之后，完成<code>Diff</code>。但是我们通过观察可以发现，只要将<code>DOM-C</code>移动到<code>DOM-A</code>之前就可以完成<code>Diff</code>。</p>
<p>这里是有可优化的空间的，接下来我们介绍<code>vue2.x</code>中的<code>diff</code>算法——<code>双端比较</code>，该算法解决了上述的问题</p>
<h3 id="4-2-Vue2-X-Diff-——-双端比较"><a href="#4-2-Vue2-X-Diff-——-双端比较" class="headerlink" title="#4.2 Vue2.X Diff —— 双端比较"></a><a target="_blank" rel="noopener" href="https://interview2.poetries.top/docs/excellent-docs/16-%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html#_4-2-vue2-x-diff-%E5%8F%8C%E7%AB%AF%E6%AF%94%E8%BE%83">#</a>4.2 Vue2.X Diff —— 双端比较</h3><p>所谓<code>双端比较</code>就是<strong>新列表</strong>和<strong>旧列表</strong>两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。</p>
<p><strong>1. 实现原理</strong></p>
<p>我们先用四个指针指向两个列表的头尾</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>,</span><br><span class="line">    oldEndIndex = prevChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    newStartIndex = <span class="number">0</span>,</span><br><span class="line">    newEndIndex = nextChildren.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartNode = prevChildren[oldStartIndex],</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex],</span><br><span class="line">    newStartNode = nextChildren[nextStartIndex],</span><br><span class="line">    newEndNode = nextChildren[nextEndIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比</p>
<ol>
<li>使用<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比</li>
<li>使用<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比</li>
<li>使用<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比</li>
<li>使用<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比</li>
</ol>
<p>使用以上四步进行对比，去寻找<code>key</code>相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359054.png" alt="img"></p>
<p>对比顺序代码结构如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>,</span><br><span class="line">    oldEndIndex = prevChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    newStartIndex = <span class="number">0</span>,</span><br><span class="line">    newEndIndex = nextChildren.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartNode = prevChildren[oldStartIndex],</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex],</span><br><span class="line">    newStartNode = nextChildren[newStartIndex],</span><br><span class="line">    newEndNode = nextChildren[newEndIndex];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当对比时找到了可复用的节点，我们还是先<code>patch</code>给元素打补丁，然后将指针进行<code>前/后移</code>一位指针。根据对比节点的不同，我们移动的<strong>指针</strong>和<strong>方向</strong>也不同，具体规则如下：</p>
<ol>
<li>当<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的头指针<code>oldStartIndex</code>与<strong>新列表</strong>的头指针<code>newStartIndex</code>同时向<strong>后</strong>移动一位。</li>
<li>当<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的尾指针<code>oldEndIndex</code>与<strong>新列表</strong>的尾指针<code>newEndIndex</code>同时向<strong>前</strong>移动一位。</li>
<li>当<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的头指针<code>oldStartIndex</code>向<strong>后</strong>移动一位；<strong>新列表</strong>的尾指针<code>newEndIndex</code>向<strong>前</strong>移动一位。</li>
<li>当<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的尾指针<code>oldEndIndex</code>向<strong>前</strong>移动一位；<strong>新列表</strong>的头指针<code>newStartIndex</code>向<strong>后</strong>移动一位。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>,</span><br><span class="line">    oldEndIndex = prevChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    newStartIndex = <span class="number">0</span>,</span><br><span class="line">    newEndIndex = nextChildren.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartNode = prevChildren[oldStartIndex],</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex],</span><br><span class="line">    newStartNode = nextChildren[newStartIndex],</span><br><span class="line">    newEndNode = nextChildren[newEndIndex];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldvStartNode, newStartNode, parent)</span><br><span class="line"></span><br><span class="line">    oldStartIndex++</span><br><span class="line">    newStartIndex++</span><br><span class="line">    oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">    newStartNode = nextChildren[newStartIndex]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldEndNode, newEndNode, parent)</span><br><span class="line"></span><br><span class="line">    oldEndIndex--</span><br><span class="line">    newEndIndex--</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex]</span><br><span class="line">    newEndNode = nextChildren[newEndIndex]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldStartNode, newEndNode, parent)</span><br><span class="line"></span><br><span class="line">    oldStartIndex++</span><br><span class="line">    newEndIndex--</span><br><span class="line">    oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">    newEndNode = nextChildren[newEndIndex]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldEndNode, newStartNode, parent)</span><br><span class="line"></span><br><span class="line">    oldEndIndex--</span><br><span class="line">    nextStartIndex++</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex]</span><br><span class="line">    newStartNode = nextChildren[newStartIndex]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在小节的开头，提到了要让指针向内靠拢，所以我们需要循环。循环停止的条件是当其中一个列表的节点全部遍历完成，代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>,</span><br><span class="line">    oldEndIndex = prevChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    newStartIndex = <span class="number">0</span>,</span><br><span class="line">    newEndIndex = nextChildren.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartNode = prevChildren[oldStartIndex],</span><br><span class="line">    oldEndNode = prevChildren[oldEndIndex],</span><br><span class="line">    newStartNode = nextChildren[newStartIndex],</span><br><span class="line">    newEndNode = nextChildren[newEndIndex];</span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldStartNode, newStartNode, parent)</span><br><span class="line"></span><br><span class="line">      oldStartIndex++</span><br><span class="line">      newStartIndex++</span><br><span class="line">      oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldEndNode, newEndNode, parent)</span><br><span class="line"></span><br><span class="line">      oldEndIndex--</span><br><span class="line">      newndIndex--</span><br><span class="line">      oldEndNode = prevChildren[oldEndIndex]</span><br><span class="line">      newEndNode = nextChildren[newEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldvStartNode, newEndNode, parent)</span><br><span class="line"></span><br><span class="line">      oldStartIndex++</span><br><span class="line">      newEndIndex--</span><br><span class="line">      oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">      newEndNode = nextChildren[newEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldEndNode, newStartNode, parent)</span><br><span class="line"></span><br><span class="line">      oldEndIndex--</span><br><span class="line">      newStartIndex++</span><br><span class="line">      oldEndNode = prevChildren[oldEndIndex]</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：</p>
<ul>
<li>什么情况下<code>DOM</code>节点需要移动</li>
<li><code>DOM</code>节点如何移动</li>
</ul>
<p>我们来解决第一个问题：<strong>什么情况下需要移动</strong>，我们还是以上图为例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359533.png" alt="img"></p>
<p>当我们在第一个循环时，在<code>第四步</code>发现<strong>旧列表的尾节点</strong><code>oldEndNode</code>与<strong>新列表的头节点</strong><code>newStartNode</code>的<code>key</code>相同，是可复用的<code>DOM</code>节点。通过观察我们可以发现，<strong>原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldEndNode, newStartNode, parent)</span><br><span class="line">      <span class="comment">// 移动到旧列表头节点之前</span></span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldEndNode.<span class="property">el</span>, oldStartNode.<span class="property">el</span>)</span><br><span class="line"></span><br><span class="line">      oldEndIndex--</span><br><span class="line">      newStartIndex++</span><br><span class="line">      oldEndNode = prevChildren[oldEndIndex]</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359184.png" alt="img"></p>
<p>然后我们进入第二次循环，我们在<code>第二步</code>发现，<strong>旧列表的尾节点</strong><code>oldEndNode</code>和<strong>新列表的尾节点</strong><code>newEndNode</code>为复用节点。<strong>原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动</strong>，所以我们什么都不需要做。</p>
<p>同理，如果是<strong>旧列表的头节点</strong><code>oldStartNode</code>和<strong>新列表的头节点</strong><code>newStartNode</code>为复用节点，我们也什么都不需要做。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359531.png" alt="img"></p>
<p>进入第三次循环，我们在<code>第三部</code>发现，<strong>旧列表的头节点</strong><code>oldStartNode</code>和<strong>新列表的尾节点</strong><code>newEndNode</code>为复用节点。到这一步聪明如你肯定就一眼可以看出来了，我们只要将<code>DOM-A</code>移动到<code>DOM-B</code>后面就可以了。</p>
<p>依照惯例我们还是解释一下，<strong>原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldStartNode, newEndNode, parent)</span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldStartNode.<span class="property">el</span>, oldEndNode.<span class="property">el</span>.<span class="property">nextSibling</span>)</span><br><span class="line"></span><br><span class="line">      oldStartIndex++</span><br><span class="line">      newEndIndex--</span><br><span class="line">      oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">      newEndNode = nextChildren[newEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359343.png" alt="img"></p>
<p>OK，进入最后一个循环。在<code>第一步</code><strong>旧列表</strong>头节点<code>oldStartNode</code>与<strong>新列表</strong>头节点<code>newStartNode</code>位置相同，所以啥也不用做。然后结束循环，这就是<code>Vue2 双端比较</code>的原理。</p>
<p><strong>2. 非理想情况</strong></p>
<p>上一小节，我们讲了<code>双端比较</code>的原理，但是有一种特殊情况，当四次对比都<strong>没找到</strong>复用节点时，我们只能拿<strong>新列表</strong>的第一个节点去<strong>旧列表</strong>中找与其<code>key</code>相同的节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359968.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span></span><br><span class="line">      <span class="keyword">let</span> newKey = newStartNode.<span class="property">key</span>,</span><br><span class="line">        oldIndex = prevChildren.<span class="title function_">findIndex</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="property">key</span> === newKey);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找节点的时候其实会有两种情况：一种在<strong>旧列表</strong>中找到了，另一种情况是没找到。我们先以上图为例，说一下找到的情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211359489.png" alt="img"></p>
<p>当我们在旧列表中找到对应的<code>VNode</code>，我们只需要将找到的节点的<code>DOM</code>元素，移动到开头就可以了。这里的逻辑其实和<code>第四步</code>的逻辑是一样的，只不过<code>第四步</code>是移动的尾节点，这里是移动找到的节点。<code>DOM</code>移动后，由我们将<strong>旧列表</strong>中的节点改为<code>undefined</code>，这是<strong>至关重要</strong>的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针<code>newStartIndex</code>向后移一位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span></span><br><span class="line">      <span class="keyword">let</span> newtKey = newStartNode.<span class="property">key</span>,</span><br><span class="line">        oldIndex = prevChildren.<span class="title function_">findIndex</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="property">key</span> === newKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (oldIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldNode = prevChildren[oldIndex];</span><br><span class="line">        <span class="title function_">patch</span>(oldNode, newStartNode, parent)</span><br><span class="line">        parent.<span class="title function_">insertBefore</span>(oldNode.<span class="property">el</span>, oldStartNode.<span class="property">el</span>)</span><br><span class="line">        prevChildren[oldIndex] = <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">      newStartNode = nextChildren[++newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果在<strong>旧列表</strong>中没有找到复用节点呢？很简单，直接创建一个新的节点放到最前面就可以了，然后后移头指针<code>newStartIndex</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400801.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span></span><br><span class="line">      <span class="keyword">let</span> newtKey = newStartNode.<span class="property">key</span>,</span><br><span class="line">        oldIndex = prevChildren.<span class="title function_">findIndex</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="property">key</span> === newKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (oldIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldNode = prevChildren[oldIndex];</span><br><span class="line">        <span class="title function_">patch</span>(oldNode, newStartNode, parent)</span><br><span class="line">        parent.<span class="title function_">insertBefore</span>(oldNode.<span class="property">el</span>, oldStartNode.<span class="property">el</span>)</span><br><span class="line">        prevChildren[oldIndex] = <span class="literal">undefined</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="title function_">mount</span>(newStartNode, parent, oldStartNode.<span class="property">el</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      newStartNode = nextChildren[++newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后当<strong>旧列表</strong>遍历到<code>undefind</code>时就跳过当前节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode === undefind) &#123;</span><br><span class="line">    	oldStartNode = prevChildren[++oldStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode === undefind) &#123;</span><br><span class="line">    	oldEndNode = prevChildren[--oldEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 添加节点</strong></p>
<p>我们先来看一个例子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400020.png" alt="img"></p>
<p>这个例子非常简单，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束，如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400324.png" alt="img"></p>
<p>此时<code>oldEndIndex</code>以及小于了<code>oldStartIndex</code>，但是<strong>新列表</strong>中还有剩余的节点，我们只需要将剩余的节点依次插入到<code>oldStartNode</code>的<code>DOM</code>之前就可以了。为什么是插入<code>oldStartNode</code>之前呢？原因是剩余的节点在<strong>新列表</strong>的位置是位于<code>oldStartNode</code>之前的，如果剩余节点是在<code>oldStartNode</code>之后，<code>oldStartNode</code>就会先行对比，这个需要思考一下，其实还是与<code>第四步</code>的思路一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldEndIndex &lt; oldStartIndex) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIndex; i &lt;= newEndIndex; i++) &#123;</span><br><span class="line">      <span class="title function_">mount</span>(nextChildren[i], parent, prevStartNode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4. 移除节点</strong></p>
<p>与上一小节的情况相反，当<strong>新列表</strong>的<code>newEndIndex</code>小于<code>newStartIndex</code>时，我们将<strong>旧列表</strong>剩余的节点删除即可。这里我们需要注意，<strong>旧列表</strong>的<code>undefind</code>。在第二小节中我们提到过，当头尾节点都不相同时，我们会去<strong>旧列表</strong>中找<strong>新列表</strong>的第一个节点，移动完 DOM 节点后，将<strong>旧列表</strong>的那个节点改为<code>undefind</code>。所以我们在最后的删除时，需要注意这些<code>undefind</code>，遇到的话跳过当前循环即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldEndIndex &lt; oldStartIndex) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIndex; i &lt;= newEndIndex; i++) &#123;</span><br><span class="line">      <span class="title function_">mount</span>(nextChildren[i], parent, prevStartNode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndIndex &lt; newStartIndex) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIndex; i &lt;= oldEndIndex; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevChildren[i]) &#123;</span><br><span class="line">        partent.<span class="title function_">removeChild</span>(prevChildren[i].<span class="property">el</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. 小结</strong></p>
<p>至此<code>双端比较</code>全部完成，以下是全部代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue2diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>,</span><br><span class="line">    newStartIndex = <span class="number">0</span>,</span><br><span class="line">    oldStartIndex = prevChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    newStartIndex = nextChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    oldStartNode = prevChildren[oldStartIndex],</span><br><span class="line">    oldEndNode = prevChildren[oldStartIndex],</span><br><span class="line">    newStartNode = nextChildren[newStartIndex],</span><br><span class="line">    newEndNode = nextChildren[newStartIndex];</span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldStartIndex &amp;&amp; newStartIndex &lt;= newStartIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartNode === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      oldStartNode = prevChildren[++oldStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      oldEndNode = prevChildren[--oldStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldStartNode, newStartNode, parent)</span><br><span class="line"></span><br><span class="line">      oldStartIndex++</span><br><span class="line">      newStartIndex++</span><br><span class="line">      oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldEndNode, newEndNode, parent)</span><br><span class="line"></span><br><span class="line">      oldStartIndex--</span><br><span class="line">      newStartIndex--</span><br><span class="line">      oldEndNode = prevChildren[oldStartIndex]</span><br><span class="line">      newEndNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartNode.<span class="property">key</span> === newEndNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldStartNode, newEndNode, parent)</span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldStartNode.<span class="property">el</span>, oldEndNode.<span class="property">el</span>.<span class="property">nextSibling</span>)</span><br><span class="line">      oldStartIndex++</span><br><span class="line">      newStartIndex--</span><br><span class="line">      oldStartNode = prevChildren[oldStartIndex]</span><br><span class="line">      newEndNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode.<span class="property">key</span> === newStartNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(oldEndNode, newStartNode, parent)</span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldEndNode.<span class="property">el</span>, oldStartNode.<span class="property">el</span>)</span><br><span class="line">      oldStartIndex--</span><br><span class="line">      newStartIndex++</span><br><span class="line">      oldEndNode = prevChildren[oldStartIndex]</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> newKey = newStartNode.<span class="property">key</span>,</span><br><span class="line">        oldIndex = prevChildren.<span class="title function_">findIndex</span>(<span class="function"><span class="params">child</span> =&gt;</span> child &amp;&amp; (child.<span class="property">key</span> === newKey));</span><br><span class="line">      <span class="keyword">if</span> (oldIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">mount</span>(newStartNode, parent, oldStartNode.<span class="property">el</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> prevNode = prevChildren[oldIndex]</span><br><span class="line">        <span class="title function_">patch</span>(prevNode, newStartNode, parent)</span><br><span class="line">        parent.<span class="title function_">insertBefore</span>(prevNode.<span class="property">el</span>, oldStartNode.<span class="property">el</span>)</span><br><span class="line">        prevChildren[oldIndex] = <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">      newStartIndex++</span><br><span class="line">      newStartNode = nextChildren[newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newStartIndex &gt; newStartIndex) &#123;</span><br><span class="line">    <span class="keyword">while</span> (oldStartIndex &lt;= oldStartIndex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!prevChildren[oldStartIndex]) &#123;</span><br><span class="line">        oldStartIndex++</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      parent.<span class="title function_">removeChild</span>(prevChildren[oldStartIndex++].<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartIndex &gt; oldStartIndex) &#123;</span><br><span class="line">    <span class="keyword">while</span> (newStartIndex &lt;= newStartIndex) &#123;</span><br><span class="line">      <span class="title function_">mount</span>(nextChildren[newStartIndex++], parent, oldStartNode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Vue3-Diff-——-最长递增子序列"><a href="#4-3-Vue3-Diff-——-最长递增子序列" class="headerlink" title="#4.3 Vue3 Diff —— 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://interview2.poetries.top/docs/excellent-docs/16-%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html#_4-3-vue3-diff-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">#</a>4.3 Vue3 Diff —— 最长递增子序列</h3><p><code>vue3</code>的<code>diff</code>借鉴于<a target="_blank" rel="noopener" href="https://github.com/infernojs/inferno">inferno (opens new window)</a>，该算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列，此思想与<code>React</code>的<code>diff</code>类似又不尽相同。下面我们来一一介绍。</p>
<p><strong>1. 前置与后置的预处理</strong></p>
<p>我们看这两段文字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hey World</span><br><span class="line"></span><br><span class="line">        @程序员poetry: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就简单的看一眼我们就能发现，这两段文字是有一部分是相同的，<strong>这些文字是不需要修改也不需要移动的</strong>，真正需要进行修改中间的几个字母，所以<code>diff</code>就变成以下部分</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text1: &#x27;llo&#x27;</span><br><span class="line">text2: &#x27;y&#x27;</span><br><span class="line"></span><br><span class="line">        @程序员poetry: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来换成<code>vnode</code>，我们以下图为例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400687.png" alt="img"></p>
<p>图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁<code>patch</code>就可以了。我们把该逻辑写成代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>,</span><br><span class="line">    prevEnd = prevChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    nextEnd = nextChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    prevNode = prevChildren[j],</span><br><span class="line">    nextNode = nextChildren[j];</span><br><span class="line">  <span class="keyword">while</span> (prevNode.<span class="property">key</span> === nextNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(prevNode, nextNode, parent)</span><br><span class="line">    j++</span><br><span class="line">    prevNode = prevChildren[j]</span><br><span class="line">    nextNode = nextChildren[j]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prevNode = prevChildren[prevEnd]</span><br><span class="line">  nextNode = prevChildren[nextEnd]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (prevNode.<span class="property">key</span> === nextNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(prevNode, nextNode, parent)</span><br><span class="line">    prevEnd--</span><br><span class="line">    nextEnd--</span><br><span class="line">    prevNode = prevChildren[prevEnd]</span><br><span class="line">    nextNode = prevChildren[nextEnd]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候，我们就需要考虑边界情况了，这里有两种情况。一种是<code>j &gt; prevEnd</code>；另一种是<code>j &gt; nextEnd</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400875.png" alt="img"></p>
<p>我们以这张图为例，此时<code>j &gt; prevEnd</code>且<code>j &lt;= nextEnd</code>，我们只需要把<strong>新列表</strong>中<code>j</code>到<code>nextEnd</code>之间剩下的节点<strong>插入</strong>进去就可以了。相反， 如果<code>j &gt; nextEnd</code>时，我们把<strong>旧列表</strong>中<code>j</code>到<code>prevEnd</code>之间的节点<strong>删除</strong>就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="keyword">let</span> nextpos = nextEnd + <span class="number">1</span>,</span><br><span class="line">      refNode = nextpos &gt;= nextChildren.<span class="property">length</span></span><br><span class="line">                ? <span class="literal">null</span></span><br><span class="line">                : nextChildren[nextpos].<span class="property">el</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= nextEnd) <span class="title function_">mount</span>(nextChildren[j++], parent, refNode)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd &amp;&amp; j &lt;= prevEnd) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= prevEnd) parent.<span class="title function_">removeChild</span>(prevChildren[j++].<span class="property">el</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们再继续思考，在我们<code>while</code>循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用<code>label</code>语法，当我们触发边界情况时，退出全部的循环，直接进入判断。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>,</span><br><span class="line">    prevEnd = prevChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    nextEnd = nextChildren.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    prevNode = prevChildren[j],</span><br><span class="line">    nextNode = nextChildren[j];</span><br><span class="line">  <span class="comment">// label语法</span></span><br><span class="line">  <span class="attr">outer</span>: &#123;</span><br><span class="line">    <span class="keyword">while</span> (prevNode.<span class="property">key</span> === nextNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(prevNode, nextNode, parent)</span><br><span class="line">      j++</span><br><span class="line">      <span class="comment">// 循环中如果触发边界情况，直接break，执行outer之后的判断</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt; prevEnd || j &gt; nextEnd) <span class="keyword">break</span> outer</span><br><span class="line">      prevNode = prevChildren[j]</span><br><span class="line">      nextNode = nextChildren[j]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevNode = prevChildren[prevEnd]</span><br><span class="line">    nextNode = prevChildren[nextEnd]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prevNode.<span class="property">key</span> === nextNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(prevNode, nextNode, parent)</span><br><span class="line">      prevEnd--</span><br><span class="line">      nextEnd--</span><br><span class="line">      <span class="comment">// 循环中如果触发边界情况，直接break，执行outer之后的判断</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt; prevEnd || j &gt; nextEnd) <span class="keyword">break</span> outer</span><br><span class="line">      prevNode = prevChildren[prevEnd]</span><br><span class="line">      nextNode = prevChildren[nextEnd]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界情况的判断</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="keyword">let</span> nextpos = nextEnd + <span class="number">1</span>,</span><br><span class="line">      refNode = nextpos &gt;= nextChildren.<span class="property">length</span></span><br><span class="line">                ? <span class="literal">null</span></span><br><span class="line">                : nextChildren[nextpos].<span class="property">el</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= nextEnd) <span class="title function_">mount</span>(nextChildren[j++], parent, refNode)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd &amp;&amp; j &lt;= prevEnd) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= prevEnd) parent.<span class="title function_">removeChild</span>(prevChildren[j++].<span class="property">el</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 判断是否需要移动</strong></p>
<p>其实几个算法看下来，套路已经很明显了，就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。这个算法也不例外，我们接下来看一下它是如何做的。</p>
<p>当<code>前/后置</code>的预处理结束后，我们进入真正的<code>diff</code>环节。首先，我们先根据<strong>新列表</strong>剩余的节点数量，创建一个<code>source</code>数组，并将数组填满<code>-1</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400253.png" alt="img"></p>
<p>我们先写这块逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">outer</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界情况的判断</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd &amp;&amp; j &lt;= prevEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prevStart = j,</span><br><span class="line">      nextStart = j,</span><br><span class="line">      nextLeft = nextEnd - nextStart + <span class="number">1</span>,     <span class="comment">// 新列表中剩余的节点长度</span></span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">Array</span>(nextLeft).<span class="title function_">fill</span>(-<span class="number">1</span>);  <span class="comment">// 创建数组，填满-1</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这个<code>source</code>数组，是要做什么的呢？他就是来做新旧节点的对应关系的，我们将<strong>新节点</strong>在<strong>旧列表</strong>的位置存储在该数组中，我们在根据<code>source</code>计算出它的<code>最长递增子序列</code>用于移动 DOM 节点。为此，我们先建立一个对象存储当前<strong>新列表</strong>中的<code>节点</code>与<code>index</code>的关系，再去<strong>旧列表</strong>中去找位置。</p>
<p>在找节点时要注意，<strong>如果旧节点在新列表中没有的话，直接删除就好</strong>。除此之外，我们还需要一个数量表示记录我们已经<code>patch</code>过的节点，如果数量已经与<strong>新列表</strong>剩余的节点数量一样，那么剩下的<code>旧节点</code>我们就直接删除了就可以了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">outer</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界情况的判断</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd &amp;&amp; j &lt;= prevEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prevStart = j,</span><br><span class="line">      nextStart = j,</span><br><span class="line">      nextLeft = nextEnd - nextStart + <span class="number">1</span>,     <span class="comment">// 新列表中剩余的节点长度</span></span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">Array</span>(nextLeft).<span class="title function_">fill</span>(-<span class="number">1</span>),  <span class="comment">// 创建数组，填满-1</span></span><br><span class="line">      nextIndexMap = &#123;&#125;,                      <span class="comment">// 新列表节点与index的映射</span></span><br><span class="line">      patched = <span class="number">0</span>;                            <span class="comment">// 已更新过的节点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nextStart; i &lt;= nextEnd; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = nextChildren[i].<span class="property">key</span></span><br><span class="line">      nextIndexMap[key] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去旧列表找位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> prevNode = prevChildren[i],</span><br><span class="line">      	prevKey = prevNode.<span class="property">key</span>,</span><br><span class="line">        nextIndex = nextIndexMap[prevKey];</span><br><span class="line">      <span class="comment">// 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点</span></span><br><span class="line">      <span class="keyword">if</span> (nextIndex === undefind || patched &gt;= nextLeft) &#123;</span><br><span class="line">        parent.<span class="title function_">removeChild</span>(prevNode.<span class="property">el</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到对应的节点</span></span><br><span class="line">      <span class="keyword">let</span> nextNode = nextChildren[nextIndex];</span><br><span class="line">      <span class="title function_">patch</span>(prevNode, nextNode, parent);</span><br><span class="line">      <span class="comment">// 给source赋值</span></span><br><span class="line">      source[nextIndex - nextStart] = i</span><br><span class="line">      patched++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400806.png" alt="img"></p>
<p>找到位置后，我们观察这个重新赋值后的<code>source</code>，我们可以看出，如果是全新的节点的话，其在<code>source</code>数组中对应的值就是初始的<code>-1</code>，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。</p>
<p>其次，我们要判断是否需要移动。那么如何判断移动呢？很简单，和<code>React</code>一样我们用递增法，如果我们找到的<code>index</code>是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">outer</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界情况的判断</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd &amp;&amp; j &lt;= prevEnd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prevStart = j,</span><br><span class="line">      nextStart = j,</span><br><span class="line">      nextLeft = nextEnd - nextStart + <span class="number">1</span>,     <span class="comment">// 新列表中剩余的节点长度</span></span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">Array</span>(nextLeft).<span class="title function_">fill</span>(-<span class="number">1</span>),  <span class="comment">// 创建数组，填满-1</span></span><br><span class="line">      nextIndexMap = &#123;&#125;,                      <span class="comment">// 新列表节点与index的映射</span></span><br><span class="line">      patched = <span class="number">0</span>,</span><br><span class="line">      move = <span class="literal">false</span>,                           <span class="comment">// 是否移动</span></span><br><span class="line">      lastIndex = <span class="number">0</span>;                          <span class="comment">// 记录上一次的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nextStart; i &lt;= nextEnd; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = nextChildren[i].<span class="property">key</span></span><br><span class="line">      nextIndexMap[key] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去旧列表找位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> prevNode = prevChildren[i],</span><br><span class="line">      	prevKey = prevNode.<span class="property">key</span>,</span><br><span class="line">        nextIndex = nextIndexMap[prevKey];</span><br><span class="line">      <span class="comment">// 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点</span></span><br><span class="line">      <span class="keyword">if</span> (nextIndex === undefind || patched &gt;= nextLeft) &#123;</span><br><span class="line">        parent.<span class="title function_">removeChild</span>(prevNode.<span class="property">el</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到对应的节点</span></span><br><span class="line">      <span class="keyword">let</span> nextNode = nextChildren[nextIndex];</span><br><span class="line">      <span class="title function_">patch</span>(prevNode, nextNode, parent);</span><br><span class="line">      <span class="comment">// 给source赋值</span></span><br><span class="line">      source[nextIndex - nextStart] = i</span><br><span class="line">      patched++</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递增方法，判断是否需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (nextIndex &lt; lastIndex) &#123;</span><br><span class="line">      	move = <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	lastIndex = nextIndex</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (move) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要移动</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要移动</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. DOM 如何移动</strong></p>
<p>判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行 DOM 移动，我们首先要做的就是找到<code>source</code>的<strong>最长递增子序列</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (move) &#123;</span><br><span class="line">	<span class="keyword">const</span> seq = <span class="title function_">lis</span>(source); <span class="comment">// [0, 1]</span></span><br><span class="line">  <span class="comment">// 需要移动</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不需要移动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p>
<p>例如给定数值序列为：[ 0, 8, 4, 12 ]。</p>
<p>那么它的最长递增子序列就是：[0, 8, 12]。</p>
<p>当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的。</p>
</blockquote>
<p>上面的代码中，我们调用<code>lis</code> 函数求出数组<code>source</code>的最长递增子序列为<code>[ 0, 1 ]</code>。我们知道 source 数组的值为 <code>[2, 3, 1, -1]</code>，很显然最长递增子序列应该是<code>[ 2, 3 ]</code>，但为什么计算出的结果是<code>[ 0, 1 ]</code>呢？其实<code>[ 0, 1 ]</code>代表的是最长递增子序列中的各个元素在<code>source</code>数组中的位置索引，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211400840.png" alt="img"></p>
<p>我们根据<code>source</code>，对<strong>新列表</strong>进行重新编号，并找出了<code>最长递增子序列</code>。</p>
<p>我们从后向前进行遍历<code>source</code>每一项。此时会出现三种情况：</p>
<ol>
<li>当前的值为<code>-1</code>，这说明该节点是全新的节点，又由于我们是<strong>从后向前</strong>遍历，我们直接创建好 DOM 节点插入到队尾就可以了。</li>
<li>当前的索引为<code>最长递增子序列</code>中的值，也就是<code>i === seq[j]</code>，这说说明该节点不需要移动</li>
<li>当前的索引不是<code>最长递增子序列</code>中的值，那么说明该 DOM 节点需要移动，这里也很好理解，我们也是直接将 DOM 节点插入到队尾就可以了，因为队尾是排好序的</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (move) &#123;</span><br><span class="line">   <span class="comment">// 需要移动</span></span><br><span class="line">	<span class="keyword">const</span> seq = <span class="title function_">lis</span>(source); <span class="comment">// [0, 1]</span></span><br><span class="line">    <span class="keyword">let</span> j = seq.<span class="property">length</span> - <span class="number">1</span>;  <span class="comment">// 最长子序列的指针</span></span><br><span class="line">    <span class="comment">// 从后向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nextLeft - <span class="number">1</span>； i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> pos = nextStart + i, <span class="comment">// 对应新列表的index</span></span><br><span class="line">        nextNode = nextChildren[pos],	<span class="comment">// 找到vnode</span></span><br><span class="line">      	nextPos = pos + <span class="number">1</span>，    <span class="comment">// 下一个节点的位置，用于移动DOM</span></span><br><span class="line">        refNode = nextPos &gt;= nextChildren.<span class="property">length</span> ? <span class="literal">null</span> : nextChildren[nextPos].<span class="property">el</span>, <span class="comment">//DOM节点</span></span><br><span class="line">        cur = source[i];  <span class="comment">// 当前source的值，用来判断节点是否需要移动</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况1，该节点是全新节点</span></span><br><span class="line">      	<span class="title function_">mount</span>(nextNode, parent, refNode)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur === seq[j]) &#123;</span><br><span class="line">        <span class="comment">// 情况2，是递增子序列，该节点不需要移动</span></span><br><span class="line">        <span class="comment">// 让j指向下一个</span></span><br><span class="line">        j--</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况3，不是递增子序列，该节点需要移动</span></span><br><span class="line">        parent.<span class="title function_">insetBefore</span>(nextNode.<span class="property">el</span>, refNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//不需要移动</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vue3Diff</span>(<span class="params">prevChildren, nextChildren, parent</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (move) &#123;</span><br><span class="line">	<span class="keyword">const</span> seq = <span class="title function_">lis</span>(source); <span class="comment">// [0, 1]</span></span><br><span class="line">    <span class="keyword">let</span> j = seq.<span class="property">length</span> - <span class="number">1</span>;  <span class="comment">// 最长子序列的指针</span></span><br><span class="line">    <span class="comment">// 从后向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nextLeft - <span class="number">1</span>； i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> pos = nextStart + i, <span class="comment">// 对应新列表的index</span></span><br><span class="line">        nextNode = nextChildren[pos],	<span class="comment">// 找到vnode</span></span><br><span class="line">      	nextPos = pos + <span class="number">1</span>，    <span class="comment">// 下一个节点的位置，用于移动DOM</span></span><br><span class="line">        refNode = nextPos &gt;= nextChildren.<span class="property">length</span> ? <span class="literal">null</span> : nextChildren[nextPos].<span class="property">el</span>, <span class="comment">//DOM节点</span></span><br><span class="line">        cur = source[i];  <span class="comment">// 当前source的值，用来判断节点是否需要移动</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况1，该节点是全新节点</span></span><br><span class="line">      	<span class="title function_">mount</span>(nextNode, parent, refNode)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur === seq[j]) &#123;</span><br><span class="line">        <span class="comment">// 情况2，是递增子序列，该节点不需要移动</span></span><br><span class="line">        <span class="comment">// 让j指向下一个</span></span><br><span class="line">        j--</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况3，不是递增子序列，该节点需要移动</span></span><br><span class="line">        parent.<span class="title function_">insetBefore</span>(nextNode.<span class="property">el</span>, refNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不需要移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nextLeft - <span class="number">1</span>； i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = source[i];  <span class="comment">// 当前source的值，用来判断节点是否需要移动</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur === -<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> pos = nextStart + i, <span class="comment">// 对应新列表的index</span></span><br><span class="line">          nextNode = nextChildren[pos],	<span class="comment">// 找到vnode</span></span><br><span class="line">          nextPos = pos + <span class="number">1</span>，    <span class="comment">// 下一个节点的位置，用于移动DOM</span></span><br><span class="line">          refNode = nextPos &gt;= nextChildren.<span class="property">length</span> ? <span class="literal">null</span> : nextChildren[nextPos].<span class="property">el</span>, <span class="comment">//DOM节点</span></span><br><span class="line">      	<span class="title function_">mount</span>(nextNode, parent, refNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此<code>vue3.0</code>的 diff 完成。</p>
<p><strong>4. 最长递增子序列</strong></p>
<p>我们以该数组为例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以使用动态规划的思想考虑这个问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。</p>
<p>我们先假设只有一个值的数组<code>[13]</code>，那么该数组的最长递增子序列就是<code>[13]</code>自己本身，其长度为<code>1</code>。<strong>那么我们认为每一项的递增序列的长度值均为 1</strong></p>
<p>那么我们这次给数组增加一个值<code>[7, 13]</code>, 由于<code>7 &lt; 13</code>，所以该数组的最长递增子序列是<code>[7, 13]</code>，那么该长度为<code>2</code>。<strong>那么我们是否可以认为，当<code>[7]</code>小于<code>[13]</code>时，以<code>[7]</code>为头的递增序列的长度是，<code>[7]</code>的长度和<code>[13]</code>的长度的和</strong>，即<code>1 + 1 = 2</code>。</p>
<p>ok，我们基于这种思想来给计算一下该数组。我们先将每个值的初始赋值为<code>1</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211401709.png" alt="img"></p>
<p>首先 <code>7 &lt; 13</code> 那么<code>7</code>对应的长度就是<code>13</code>的长度再加 1，<code>1 + 1 = 2</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211401591.png" alt="img"></p>
<p>继续，我们对比<code>8</code>。我们首先和<code>7</code>比，发现不满足递增，但是没关系我们还可以继续和<code>13</code>比，<code>8 &lt; 13</code>满足递增，那么<code>8</code>的长度也是<code>13</code>的长度在加一，长度为<code>2</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211401764.png" alt="img"></p>
<p>我们再对比<code>3</code>，我们先让其与<code>8</code>进行对比，<code>3 &lt; 8</code>，那么<code>3</code>的长度是<code>8</code>的长度加一，此时<code>3</code>的长度为<code>3</code>。但是还没结束，我们还需要让<code>3</code>与<code>7</code>对比。同样<code>3 &lt; 7</code>，此时我们需要在计算出一个长度是<code>7</code>的长度加一同样是<code>3</code>，我们对比两个长度，<strong>如果原本的长度没有本次计算出的长度值大的话，我们进行替换，反之则我们保留原本的值</strong>。由于<code>3 === 3</code>，我们选择不替换。最后，我们让<code>3</code>与<code>13</code>进行对比，同样的<code>3 &lt; 13</code>，此时计算出的长度为<code>2</code>，比原本的长度<code>3</code>要小，我们选择保留原本的值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/202203211401780.png" alt="img"></p>
<p>之后的计算依次类推，最后的结果是这样的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s.poetries.work/images/image-20210220201751694.png" alt="image-20210220201751694"></p>
<p>我们从中取最大的值<code>4</code>，该值代表的<strong>最长递增子序列的个数</strong>。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lis</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>,</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">1</span>); <span class="comment">// 用于保存长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = arr[i]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> next = arr[j]</span><br><span class="line">      <span class="comment">// 如果是递增 取更大的长度值</span></span><br><span class="line">      <span class="keyword">if</span> (cur &lt; next) dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j]+<span class="number">1</span>, dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此为止，我们讲完了基础的最长递增子序列。然而在<code>vue3.0</code>中，我们需要的是最长递增子序列在原本数组中的索引。所以我们还需要在创建一个数组用于保存每个值的最长子序列所对应在数组中的<code>index</code>。具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lis</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>,</span><br><span class="line">    res = [],</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 存默认index</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>([i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = arr[i],</span><br><span class="line">      nextIndex = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 如果为-1 直接跳过，因为-1代表的是新节点，不需要进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (cur === -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> next = arr[j]</span><br><span class="line">      <span class="comment">// 满足递增条件</span></span><br><span class="line">      <span class="keyword">if</span> (cur &lt; next) &#123;</span><br><span class="line">        <span class="keyword">let</span> max = dp[j] + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 当前长度是否比原本的长度要大</span></span><br><span class="line">        <span class="keyword">if</span> (max &gt; dp[i]) &#123;</span><br><span class="line">          dp[i] = max</span><br><span class="line">          nextIndex = j</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录满足条件的值，对应在数组中的index</span></span><br><span class="line">    <span class="keyword">if</span> (nextIndex !== <span class="literal">undefined</span>) res[i].<span class="title function_">push</span>(...res[nextIndex])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index = dp.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, i, arr</span>) =&gt;</span> cur &gt; arr[prev] ? i : prev, dp.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回最长的递增子序列的index</span></span><br><span class="line">  <span class="keyword">return</span> result[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        @程序员<span class="attr">poetry</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Last Updated: 9&#x2F;20&#x2F;2022, 1:16:55 PM</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jiaobingyang.gitee.io">三乘以十的八次幂</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiaobingyang.gitee.io/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/">https://jiaobingyang.gitee.io/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiaobingyang.gitee.io" target="_blank">三乘以十的八次幂</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BF%85%E5%A4%87/">必备</a></div><div class="post_share"><div class="social-share" data-image="/img/13280497753579408.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220624081333.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220624081333.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220624081350.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220624081350.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="onerror=null;src='/img/wallhaven-e76roo.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13279652804370799.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="avatar"/></div><div class="author-info__name">三乘以十的八次幂</div><div class="author-info__description">死亡如风，常伴吾身</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BINGYANGJIAO/bingyangjiao.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BINGYANGJIAO/bingyangjiao.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:781250021@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">兴趣爱好才是最大的动力，何不与我共同攀知识高峰，品翘楚美人！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">vue 响应式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">vue 的核心是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%EF%BC%88MVVM"><span class="toc-number">2.1.</span> <span class="toc-text">数据驱动（MVVM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">组件化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">指令系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-dom%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F-dom-%E8%83%BD%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">什么是虚拟 dom、为什么虚拟 dom 能提升性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">3.1.</span> <span class="toc-text">什么是虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">3.2.</span> <span class="toc-text">为什么需要虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">3.3.</span> <span class="toc-text">如何实现虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">3.5.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">什么是组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96-1"><span class="toc-number">4.1.</span> <span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.</span> <span class="toc-text">组件通信的方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9-spa-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">说一下对 spa 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-SPA-%E5%BA%94%E7%94%A8%E5%91%A2"><span class="toc-number">6.1.</span> <span class="toc-text">你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-SPA"><span class="toc-number">6.2.</span> <span class="toc-text">一、什么是 SPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SPA-%E5%92%8C-MPA-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">二、SPA 和 MPA 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.1.</span> <span class="toc-text">单页应用与多页应用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.3.2.</span> <span class="toc-text">单页应用优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-SPA"><span class="toc-number">6.4.</span> <span class="toc-text">三、实现一个 SPA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.4.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">hash 模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#history-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">history 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%99-SPA-%E5%81%9A-SEO"><span class="toc-number">6.5.</span> <span class="toc-text">四、题外话：如何给 SPA 做 SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-1"><span class="toc-number">6.6.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E7%95%8C%E9%9D%A2%E4%B8%8D%E4%BC%9A%E5%88%B7%E6%96%B0"><span class="toc-number">7.</span> <span class="toc-text">vue 中给对象添加属性为什么界面不会刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD%E7%9A%84-key-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">vue 中的 key 属性的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.</span> <span class="toc-text">vue 的修饰符有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%88%86%E4%B8%BA%E4%BB%A5%E4%B8%8B%E4%BA%94%E7%A7%8D"><span class="toc-number">9.1.</span> <span class="toc-text">vue 中修饰符分为以下五种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84-%E5%AF%B9%E6%AF%94%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">vue 的 diff 算法是做什么的 对比方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-React-Diff"><span class="toc-number">10.1.</span> <span class="toc-text">4.1 React-Diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Vue2-X-Diff-%E2%80%94%E2%80%94-%E5%8F%8C%E7%AB%AF%E6%AF%94%E8%BE%83"><span class="toc-number">10.2.</span> <span class="toc-text">4.2 Vue2.X Diff —— 双端比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Vue3-Diff-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">10.3.</span> <span class="toc-text">4.3 Vue3 Diff —— 最长递增子序列</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="日积月累"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="日积月累"/></a><div class="content"><a class="title" href="/2022/09/27/%E6%97%A5%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="日积月累">日积月累</a><time datetime="2022-09-27T12:26:26.000Z" title="发表于 2022-09-27 20:26:26">2022-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="前端基础"/></a><div class="content"><a class="title" href="/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端基础">前端基础</a><time datetime="2022-07-06T06:40:34.000Z" title="发表于 2022-07-06 14:40:34">2022-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端进阶"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="前端进阶"/></a><div class="content"><a class="title" href="/2022/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端进阶">前端进阶</a><time datetime="2022-06-27T23:33:45.000Z" title="发表于 2022-06-28 07:33:45">2022-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/27/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9SPA%EF%BC%88%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/" title="说说你对SPA（单页应用）的理解？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="说说你对SPA（单页应用）的理解？"/></a><div class="content"><a class="title" href="/2020/06/27/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9SPA%EF%BC%88%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/" title="说说你对SPA（单页应用）的理解？">说说你对SPA（单页应用）的理解？</a><time datetime="2020-06-27T03:44:09.000Z" title="发表于 2020-06-27 11:44:09">2020-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/27/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9VUE%E7%9A%84%E7%90%86%E8%A7%A3/" title="说说你对VUE的理解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13280497753579408.jpg" onerror="this.onerror=null;this.src='/img/wallhaven-e76roo.png'" alt="说说你对VUE的理解"/></a><div class="content"><a class="title" href="/2020/06/27/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9VUE%E7%9A%84%E7%90%86%E8%A7%A3/" title="说说你对VUE的理解">说说你对VUE的理解</a><time datetime="2020-06-27T03:29:56.000Z" title="发表于 2020-06-27 11:29:56">2020-06-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 三乘以十的八次幂</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2963148865" data-server="netease" data-type="playlist" data-mini="true" data-fixed="true" data-preload="auto" data-autoplay="true"> </div><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "e0515f76-f737-4f77-ad57-761c3dc58f50";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (false) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>